#### Архітектура (FSD)

Проєкт побудований за методологією FSD. Це дозволило розділити відповідальність між шарами та забезпечити легку
підтримку коду:

- Shared: універсальні UI-компоненти (Input, Dropdown, Button).
- Entities: моделі даних (`Tour`, `Hotel`, `Geo`), сервіси для роботи з API та логіка перетворення даних (мапери та
  агрегатори).
- Features: складна бізнес-логіка, що поєднує UI та сервіси (як у `search-tours`).

#### Технічні рішення та реалізація

##### 1. Робота з асинхронними даними (Polling & Retry)

Реалізовано полінг для отримання цін:

- Dynamic Delay: час наступного запиту розраховується на основі поля `waitUntil` від сервера.
- Retry Logic: додала механізм повторних запитів (до 2-х спроб) у разі помилок мережі.
- Race Condition: `currentSearchId` (Refs) гарантує, що результати застарілих запитів не потраплять у стейт.

##### 2. Агрегація та мапінг даних

- Mappers: перетворюють відповіді API у зручні для додатка об'єкти.
- Aggregators: поєднують дані про ціни з даними про готелі за `hotel_id`.

##### 3. Оптимізація та UX

- Cancellation: при старті нового пошуку попередній активний токен скасовується на сервері (`stopSearchPrices`) та
  ігнорується на клієнті.
- Caching: результати пошуку цін кешуються за `countryId` за допомогою `useRef`, що запобігає повторним запитам при
  ідентичних параметрах.
- Debounce: пошук гео-позицій оптимізовано дебаунсом (300мс) для зменшення навантаження на сервер.

##### 4. Композиція компонентів

UI побудований за принципом LEGO:

- Контрол вибору напрямку - композиція універсального `Input` та `Dropdown`.
- Бізнес-логіка винесена у кастомні хуки (`useTourPrices`, `useEnrichedTours`, `useGeoSearch`).

##### Комментарі до виконаного завдання

- Я дотрималась принципу Inversion of Control. Мої базові компоненти в шарі Shared є 'тупими', вони не прив'язані до
  бізнес-моделей. Все прокидається в них зверху через композицію (children) або спеціалізовані хуки на рівні Features.
  Це дозволяє перевикористати Dropdown або Input у будь-якій іншій частині додатка з іншими типами даних.

- Для забезпечення розширюваності форми я використала композиційний підхід та Provider як єдине джерело істини. Нові
  items форми (DateRangePicker) додаються простим вкладенням нових компонентів у form. Бізнес-логіка кожного form-item
  ізольована у своїх хуках. Додавання нового поля (наприклад, фільтра за ціною) потребуватиме створення лише одного
  нового хука, який буде підключений до загального контексту.

- Верстка за прототипом: Виникла складність із точним відтворенням через формат скріншота - важко зрозуміти точні
  відступи, розміри шрифтів та інші деталі. Також в API немає інформації про прапор країни, а в завданні не вказано, як
  саме мають виглядати стейти (loading, error, empty). Через це я зробила їх на свій розсуд, що може не повністю
  відповідати вашим очікуванням.

- Логіка сітки: Якщо в результатах лише 1 елемент, я залишила його ліворуч (як і інші картки), оскільки не було вказано,
  чи має він центнуватися в такому випадку.

- UI-kit: Я не впроваджувала ui-kit (глобальні шрифти, кольори тощо), оскільки цього не було вказано в завданні, і фокус
  був на архітектурі та логіці.